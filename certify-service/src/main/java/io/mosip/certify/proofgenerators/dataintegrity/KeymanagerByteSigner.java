package io.mosip.certify.proofgenerators.dataintegrity;

import com.danubetech.keyformats.crypto.ByteSigner;
import io.ipfs.multibase.Multibase;
import io.mosip.certify.core.constants.ErrorConstants;
import io.mosip.certify.core.exception.CertifyException;
import io.mosip.kernel.signature.dto.SignRequestDtoV2;
import io.mosip.kernel.signature.service.SignatureServicev2;
import org.apache.logging.log4j.util.Strings;

import java.security.GeneralSecurityException;
import java.util.Base64;

/**
 * KeymanagerByteSigner is a concrete implementation of ByteSigner that
 * interacts with the Keymanager to sign data using a specified crypto suite.
 * <p>
 * It supports signing data integrity proofs as per the Data Integrity VC
 * specification.</p>
 *
 * * Spec: https://www.w3.org/TR/2025/REC-vc-data-integrity-20250515/
 */
public class KeymanagerByteSigner extends ByteSigner {

    private String appId;
    private String refId;
    private String jwsAlgorithm;
    private SignatureServicev2 signatureService;

    /**
     * @param appId
     * @param refId
     * @param signatureService
     * @param jwsAlgorithm
     */
    public KeymanagerByteSigner(String appId, String refId,
                                SignatureServicev2 signatureService, String jwsAlgorithm) {
        super(jwsAlgorithm);
        this.appId = appId;
        this.refId = refId;
        this.signatureService = signatureService;
        this.jwsAlgorithm = jwsAlgorithm;
    }

    /**
     * VC algorithm signer which can be used to sign canonicalized hashed data
     *  using the implementation from danubetech's VC signing library.
     *
     * @param bytes input data to sign, must be a canonicalized hash
     * @return signature generated by the Keymanager
     * @throws CertifyException when the algo-cryptoSuite combination is not
     *  supported or sufficient data is not provided
     */
    @Override
    public byte[] sign(byte[] bytes) throws GeneralSecurityException {
        if (Strings.isEmpty(appId) || Strings.isEmpty(refId)) {
            throw new CertifyException(ErrorConstants.MISSING_APPLICATION_OR_REFERENCE_ID);
        }
        // Map the cryptoSuite to the JWA Algorithm
        SignRequestDtoV2 s = new SignRequestDtoV2();
        s.setApplicationId(appId);
        s.setReferenceId(refId);
        // TODO: Get the relevant key from the Keymanager based on appId and refId
        s.setSignAlgorithm(jwsAlgorithm);
        s.setDataToSign(Base64.getUrlEncoder().encodeToString(bytes));
        s.setResponseEncodingFormat("base58btc");
        String sign = signatureService.signv2(s).getSignature();
        return Multibase.decode(sign);
        // business logic to call keymanager correctly based on appId, referenceId,
        //  algo, format and spit out the signature
    }
}