package io.mosip.certify.proofgenerators.dip;

import com.danubetech.keyformats.crypto.ByteSigner;
import com.google.common.collect.ImmutableMap;
import io.mosip.certify.core.constants.ErrorConstants;
import io.mosip.certify.core.constants.SignatureAlg;
import io.mosip.certify.core.exception.CertifyException;
import io.mosip.kernel.signature.dto.SignRequestDtoV2;
import io.mosip.kernel.signature.service.SignatureServicev2;
import org.apache.logging.log4j.util.Strings;

import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.util.Base64;
import java.util.Map;
import java.util.Set;

/**
 * KeymanagerByteSigner is a concrete implementation of ByteSigner that
 * interacts with the Keymanager to sign data using a specified crypto suite.
 * <p>
 * It supports signing data integrity proofs as per the Data Integrity VC
 * specification.</p>
 *
 * * Spec: https://www.w3.org/TR/2025/REC-vc-data-integrity-20250515/
 */
public class KeymanagerByteSigner extends ByteSigner {

    private String appId;
    private String refId;
    //    private String crytoSuite;
    private SignatureServicev2 signatureService;

    public final static Set<String> SUPPORTED_ALGORITHMS = Set.of(SignatureAlg.EC_RDFC_2019);
    public final static Map<String, String> CRYPTO_SUITE_TO_JWA_ALGO = ImmutableMap.of(
            SignatureAlg.EC_RDFC_2019, "ES256K");

    /**
     * @param cryptoSuite -- DataIntegritySuite suite for VC signing, JWSAlgorithm can be found out
     * @param appId
     * @param refId
     * @param signatureService
     */
    public KeymanagerByteSigner(String cryptoSuite,
                                String appId, String refId,
                                SignatureServicev2 signatureService) {
        super(cryptoSuite);
        this.appId = appId;
        this.refId = refId;
        this.signatureService = signatureService;
    }

    /**
     * VC algorithm signer which can be used to sign canonicalized hashed data
     *  using the implementation from danubetech's VC signing library.
     *
     * @param bytes input data to sign, must be a canonicalized hash
     * @return signature generated by the Keymanager
     * @throws CertifyException when the algo-cryptoSuite combination is not
     *  supported or sufficient data is not provided
     */
    @Override
    protected byte[] sign(byte[] bytes) throws GeneralSecurityException {
        if (Strings.isEmpty(appId) || Strings.isEmpty(refId)) {
            throw new CertifyException(ErrorConstants.MISSING_APPLICATION_OR_REFERENCE_ID);
        }
        // Map the cryptoSuite to the JWA Algorithm
        SignRequestDtoV2 s = new SignRequestDtoV2();
        s.setApplicationId(appId);
        s.setReferenceId(refId);
        // TODO: Get the relevant key from the Keymanager based on appId and refId
        s.setSignAlgorithm("ES256");
        s.setDataToSign(Base64.getUrlEncoder().encodeToString(bytes));
        s.setResponseEncodingFormat("base58btc");
        String sign = signatureService.signv2(s).getSignature();
        return sign.getBytes(StandardCharsets.UTF_8);
        // business logic to call keymanager correctly based on appId, referenceId,
        //  algo, format and spit out the signature
    }
}